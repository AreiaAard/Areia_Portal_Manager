<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<muclient>
<plugin
   name="Areia_Portal_Manager"
   author="Areia"
   id="8e5f000d72c9f11a6debbc6b"
   language="Lua"
   purpose="Streamline use of chaos, limited-use, and other portals"
   save_state="n"
   date_written="2021-05-30 07:00:00"
   requires="5.06"
   version="0.00"
   >
<description trim="y">
<![CDATA[
]]>
</description>

</plugin>

<include name="constants.lua"/>



<aliases>
    <alias
     match="^apm\s+(?:display|li?st?|show)(?:\s+(?<type>\w+))?$"
     enabled="y"
     script="PortalHandler.list"
     regexp="y"
     ignore_case="y"
     sequence="100"
    ></alias>
    <alias
     match="^apm\s+(?<enable>en|dis)able\s+(?<type>\w+)(?:\s+(?<index>\w+))?$"
     enabled="y"
     script="PortalHandler.enable"
     regexp="y"
     ignore_case="y"
     sequence="100"
    ></alias>
</aliases>



<triggers>
    <trigger
     match="^.+? implodes after its final use\.$"
     enabled="Y"
     script="PortalHandler.implode"
     regexp="y"
     sequence="100"
    ></trigger>
</triggers>



<script>
<![CDATA[
require "commas"
require "copytable"
require "gmcphelper"
require "tprint"
require "var"
require "wait"
dofile(GetInfo(60) .. "aardwolf_colors.lua")



--------------------------------------------------
-- PortalHandler
--------------------------------------------------

PortalHandler = {}

function PortalHandler.initialize()
    PortalHandler.DISABLE = 500
    PortalHandler.PORTAL_TYPE = {
        ["CHAOS"] = "CH", ["HERO_ONLY"] = "HO", ["LIMITED_USE"] = "LU",
        ["NOSAVE"] = "NS", ["STANDARD"] = "ST"
    }
end

function PortalHandler.list(alias, line, wc)
    local arg = wc.type:lower()
    if (arg == "" or arg == "all") then
        PortalHandler.list_all()
        return
    end
    local short = PortalHandler.get_type(arg)
    if (not short) then
        Utility.plugin_msg("Invalid portal type: @R" .. arg)
        return
    end
    PortalHandler.list_type(short)
end

function PortalHandler.list_all()
    PortalHandler.list_type(PortalHandler.PORTAL_TYPE.STANDARD)
    PortalHandler.list_type(PortalHandler.PORTAL_TYPE.CHAOS)
    PortalHandler.list_type(PortalHandler.PORTAL_TYPE.HEROONLY)
    PortalHandler.list_type(PortalHandler.PORTAL_TYPE.LIMITED_USE)
    PortalHandler.list_type(PortalHandler.PORTAL_TYPE.NOSAVE)
end

function PortalHandler.list_type(portalType)
    local short, long = PortalHandler.get_type(portalType)
    local title = Utility.pascal_case(long) .. " Portals:"
    local dirPattern = DB.fixsql(short .. "port %") -- eg, to match chport xxx
    local sql = [[
        SELECT rooms.name as room, rooms.area, exits.touid,
        exits.fromuid, exits.dir, exits.level
        FROM exits LEFT OUTER JOIN rooms ON rooms.uid=exits.touid
        WHERE exits.fromuid='*' AND exits.dir LIKE %s
        ORDER BY rooms.area,exits.touid
    ]]
    local portals = DB.query(sql:format(dirPattern))
    PortalHandler.display_list(title, portals)
end

function PortalHandler.display_list(title, portals)
    local charLevel = tonumber(gmcp("char.status.level")) or 1
    local charTier = tonumber(gmcp("char.base.tier")) or 0
    local effectiveCharLevel = charTier * 10 + charLevel
    local seperator = "+-----+------------+----------------------+-------+----------------------+-----+"
    local header = "|   # | area       | room name            |  vnum | portal commands      | lvl |"
    Utility.print(title)
    Utility.print(seperator)
    Utility.print(header)
    Utility.print(seperator)
    for i, portal in ipairs(portals) do
        local area = portal.area or "N/A"
        local room = portal.room or "N/A"
        local level = portal.level
        local disabled = level >= PortalHandler.DISABLE
        -- now that we know whether the portal is disabled, we set the level to
        -- the actual portal's level for displaying
        level = disabled and level - PortalHandler.DISABLE or level
        local text = string.format(
            "|%s%+3.3s | %-10.10s | %-20.20s | %+5.5s | %-20.20s | %+3.3s |",
            disabled and "x" or " ", i, area, room, portal.touid, portal.dir, level
        )
        if (level > effectiveCharLevel) then
            -- char cannot use this portal, so simply print it
            Utility.print((disabled and "@w" or "@G") .. text)
        else
            -- char can use the portal; make the line clickable
            local action = "mapper goto " .. portal.touid
            local hint = string.format("Click here to run to %s\n[ %s ]", room, portal.dir)
            local textColor = disabled and "silver" or "lightgreen"
            Hyperlink(action, text, hint, textColor, "black", false, true)
            Note("")
        end
    end
    Utility.print("+-------------------------------------------------+\n")
end

function PortalHandler.enable(alias, line, wc)
    local short = PortalHandler.get_type(wc.type)
    if (not short) then
        Utility.plugin_msg("Invalid portal type: @R" .. arg)
        return
    end
    local index = wc.index
    local enable = wc.enable == "en"
    if (index == "") then
        PortalHandler.enable_type(short, enable)
        return
    end
    index = tonumber(index)
    if (not index) then
        Utility.plugin_msg(string.format(
            "Invalid index: @R%s@w. Must be a number.", wc.index
        ))
        return
    end
    PortalHandler.enable_index(short, index, enable)
end

function PortalHandler.enable_type(portalType, enable)
    if (enable == nil) then
        enable = true
    end
    local short, long = PortalHandler.get_type(portalType)
    local dirPattern = DB.fixsql(short .. "port %")
    local sql = [[
        UPDATE exits SET level = level %s %s
        WHERE fromuid='*' AND dir LIKE %s AND level%s%s
    ]]
    local changes = DB.exec(sql:format(
        enable and "-" or "+", -- reduce level if enabling; otherwise increase
        PortalHandler.DISABLE, -- change level by this much
        dirPattern, -- for exits that use this format
        enable and ">=" or "<", -- if enable, only affect disabled portals and vice versa
        PortalHandler.DISABLE -- level threshold
    ))
    if (changes == 0) then
        Utility.plugin_msg(string.format(
            "No portals modified. Either all %s portals", long:lower()
        ), string.format(
            "are already %sabled, or something went wrong.",
            enable and "en" or "dis"
        ))
        return
    end
    Utility.plugin_msg(string.format(
        "%sabled %d %s portal%s.",
        enable and "En" or "Dis", changes,
        long:lower(), changes == 1 and "" or "s"
    ))
end

function PortalHandler.enable_index(portalType, index, enable)
    if (enable == nil) then
        enable = true
    end
    index = tonumber(index) or 1
    local short, long = PortalHandler.get_type(portalType)
    local dirPattern = DB.fixsql(short .. "port %")
    local sql = [[
        SELECT rooms.name as room, rooms.area, exits.touid,
        exits.fromuid, exits.dir, exits.level
        FROM exits LEFT OUTER JOIN rooms ON rooms.uid=exits.touid
        WHERE exits.fromuid='*' AND exits.dir LIKE %s
        ORDER BY rooms.area,exits.touid
    ]]
    local portals = DB.query(sql:format(dirPattern))
    local portal = portals[index]
    if (not portal) then
        Utility.plugin_msg(string.format(
            "Could not find portal #%d in the list of %s portals.",
            index, long:lower()
        ))
        return
    end
    local sql = [[
        UPDATE exits SET level = level %s %s
        WHERE fromuid='*' AND dir = %s AND level%s%s
    ]]
    local changes = DB.exec(sql:format(
        enable and "-" or "+", PortalHandler.DISABLE, DB.fixsql(portal.dir),
        enable and ">=" or "<", PortalHandler.DISABLE
    ))
    Utility.plugin_msg(string.format(
        "%sabled %s portal #%d with keywords '%s'.",
        enable and "En" or "Dis", long:lower(), index, portal.dir
    ))
end

function PortalHandler.implode(trigger, line, wc)
    local uid = gmcp("room.info.num")
    local sql = [[
        UPDATE exits SET level = level + %s
        WHERE fromuid = '*' AND dir LIKE 'luport %%'
        AND touid = %s AND level <= %s
    ]]
    local changes = DB.exec(sql:format(
        PortalHandler.DISABLE, uid, PortalHandler.DISABLE
    ))
    if (changes >= 0) then
        Utility.plugin_msg(string.format(
            "Disabled limited-use portal leading to room #%s.", uid
        ))
    end
end

function PortalHandler.get_type(portalType)
    portalType = portalType:upper()
    for long, short in pairs(PortalHandler.PORTAL_TYPE) do
        if (portalType == long or portalType == short) then
            return short:lower(), long:gsub("_", "-"):lower()
        end
    end
    return nil, nil
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- DB
--------------------------------------------------

DB = {}

function DB.initialize()
    DB.db = nil
end

function DB.open()
    local directory = GetInfo(66)
    local world = DB.sanitize_filename(WorldName())
    local mapperDB = string.format("%s%s.db.fake", directory, world)
    local db, errcode, errmsg = sqlite3.open(mapperDB)
    if not (db and db:isopen()) then
        DB.error_msg("open", errcode, errmsg)
        return false
    end
    DB.db = db
    return true
end

function DB.close()
    if not (DB.db and DB.db:isopen()) then
        return true
    end
    local code = DB.db:close()
    DB.db = nil
    if (code == -1) then
        DB.error_msg("close", code, "Database id not found.")
    elseif (code == -2) then
        DB.error_msg("close", code, "Database not open.")
    end
    return code == sqlite3.OK
end

function DB.query(sql)
    local results = {}
    if (not DB.open()) then
        return results
    end
    for result in DB.db:nrows(sql) do
        table.insert(results, result)
    end
    DB.close()
    return results
end

function DB.exec(sql)
    local changes = 0
    local cmd = sql
    if (type(cmd) == "table") then
        table.insert(cmd, 1, "BEGIN TRANSACTION")
        table.insert(cmd, "COMMIT")
        cmd = table.concat(cmd, ";")
    end
    if (not DB.open()) then
        return changes
    end
    if (DB.check(DB.db:exec(cmd))) then
        changes = DB.db:changes()
    end
    DB.close()
    return changes
end

function DB.check(code)
    if (code == sqlite3.OK or code == sqlite3.ROW or code == sqlite3.DONE) then
        return true
    end
    local errmsg = DB.db:errmsg()
    DB.db:exec("ROLLBACK")
    DB.error_msg("modify", code, errmsg)
    return false
end

function DB.error_msg(action, code, msg)
    Utility.plugin_msg(string.format(
        "@RError@w. Failed to %s the mapper database (code %s).", action, code
    ), msg)
end

function DB.fixsql(sql)
    if (type(sql) == "boolean") then
        return sql and 1 or 0
    end
    if (not sql) then
        return "NULL"
    end
    return string.format("'%s'", string.gsub(sql, "'", "''"))
end

function DB.sanitize_filename(filename)
    return trim(string.gsub(filename, "[^%w%s()_-]", ""))
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Utility
--------------------------------------------------

Utility = {}

function Utility.initialize()
    local initializers = {
        PortalHandler.initialize,
        DB.initialize,
    }
    for _, initializer in ipairs(initializers) do
        initializer()
    end
end

function Utility.deinitialize()
end

function Utility.print(str)
    -- Lets us use Aard color codes in our ColourNotes
    AnsiNote(stylesToANSI(ColoursToStyles(string.format("@w%s@w", str))))
end

function Utility.plugin_msg(str, ...)
    Utility.print(string.format("[@YPortal_Manager@w]: %s", str))
    for _, msg in ipairs{...} do
        Utility.second_msg(msg)
    end
end

function Utility.second_msg(str)
    Utility.print(string.format("                  %s", str))
end

function Utility.display_greeting()
end

function Utility.pascal_case(str)
    str = str:gsub("(%a)([%w_']*)",
        function(first,remainder)
            return string.format("%s%s", first:upper(), remainder:lower())
        end
    )
    return str
end

function Utility.starts_with(s, t)
    if not (type(s) == "string" and type(t) == "string") then
        return false
    end
    return s:sub(1, #t) == t
end
]]>
</script>



<script>
<![CDATA[
--------------------------------------------------
-- Plugin Callbacks
--------------------------------------------------

function OnPluginInstall()
    Utility.initialize()
    Utility.display_greeting()
end

function OnPluginEnable()
    OnPluginInstall()
end

function OnPluginClose()
    Utility.deinitialize()
end

function OnPluginDisable()
    OnPluginClose()
end

function OnPluginBroadcast(msg, id, name, text)
    if (id == "3e7dedbe37e44942dd46d264") then
    end
end
]]>
</script>


</muclient>
